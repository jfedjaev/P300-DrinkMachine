function [methodinfo,structs,enuminfo,ThunkLibName]=mpdevproto
%MPDEV Create structures to define interfaces found in 'mpdev'.

%This function was generated by loadlibrary.m parser version 1.1.6.35 on Mon Mar 26 13:44:57 2012
%perl options:'mpdev.i -outfile=mpdev.m'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival);
ThunkLibName=[];
%  MPRETURNCODE _stdcall configChannelByPresetID ( const DWORD n , const char * uid ); 
fcns.name{fcnNum}='configChannelByPresetID'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'ulong', 'cstring'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall connectMPDev ( const MPTYPE type , const MPCOMTYPE method , const char * MP150SN ); 
fcns.name{fcnNum}='connectMPDev'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'MP_TYPE', 'MP_COM_TYPE', 'cstring'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall disconnectMPDev (); 
fcns.name{fcnNum}='disconnectMPDev'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall findAllMP150 (); 
fcns.name{fcnNum}='findAllMP150'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall getChScaledInputRange ( const DWORD n , double * minRange , double * maxRange ); 
fcns.name{fcnNum}='getChScaledInputRange'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'ulong', 'doublePtr', 'doublePtr'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall getDigitalIO ( const DWORD n , BOOL * state , const DIGITALOPT opt ); 
fcns.name{fcnNum}='getDigitalIO'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'ulong', 'int32Ptr', 'DIGITAL_OPT'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall getMostRecentSample ( double data []); 
fcns.name{fcnNum}='getMostRecentSample'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'doublePtr'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall getMPBuffer ( const DWORD numSamples , double buff []); 
fcns.name{fcnNum}='getMPBuffer'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'ulong', 'doublePtr'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall getMPDaemonLastError (); 
fcns.name{fcnNum}='getMPDaemonLastError'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall getStatusMPDev (); 
fcns.name{fcnNum}='getStatusMPDev'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall loadXMLPresetFile ( const char * filename ); 
fcns.name{fcnNum}='loadXMLPresetFile'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'cstring'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall readAvailableMP150SN ( char buff [], const DWORD numchartoread , DWORD * numcharread ); 
fcns.name{fcnNum}='readAvailableMP150SN'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'cstring', 'ulong', 'uint32Ptr'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall receiveMPData ( double buff [], const DWORD numdatapoints , DWORD * numreceived ); 
fcns.name{fcnNum}='receiveMPData'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'doublePtr', 'ulong', 'uint32Ptr'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall setAcqChannels ( const BOOL analogCH []); 
fcns.name{fcnNum}='setAcqChannels'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'int32Ptr'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall setAnalogChScale ( const DWORD n , const double unscaled1 , const double scaled1 , const double unscaled2 , const double scaled2 ); 
fcns.name{fcnNum}='setAnalogChScale'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'ulong', 'double', 'double', 'double', 'double'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall setAnalogOut ( const double value , const int outchan ); 
fcns.name{fcnNum}='setAnalogOut'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'double', 'int32'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall setAnalogOutputMode ( const MP3XOUTMODE mode ); 
fcns.name{fcnNum}='setAnalogOutputMode'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'MP3XOUTPUT_OPT'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall setDigitalAcqChannels ( const BOOL digitalCH []); 
fcns.name{fcnNum}='setDigitalAcqChannels'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'int32Ptr'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall setDigitalIO ( const DWORD n , const BOOL state , const BOOL setnow , const DIGITALOPT opt ); 
fcns.name{fcnNum}='setDigitalIO'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'ulong', 'int32', 'int32', 'DIGITAL_OPT'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall setMPTrigger ( const TRIGGEROPT option , const BOOL posEdge , const double level , const DWORD chNum ); 
fcns.name{fcnNum}='setMPTrigger'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'TRIGGER_OPT', 'int32', 'double', 'ulong'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall setSampleRate ( const double rate ); 
fcns.name{fcnNum}='setSampleRate'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}={'double'};fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall startAcquisition (); 
fcns.name{fcnNum}='startAcquisition'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall startMPAcqDaemon (); 
fcns.name{fcnNum}='startMPAcqDaemon'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  MPRETURNCODE _stdcall stopAcquisition (); 
fcns.name{fcnNum}='stopAcquisition'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='MP_RETURN_CODE'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
enuminfo.TRIGGER_OPT=struct('MPTRIGOFF',1,'MPTRIGEXT',2,'MPTRIGACH',3,'MPTRIGDCH',4);
enuminfo.MP3XOUTPUT_OPT=struct('OUTPUTVOLTAGELEVEL',2,'OUTPUTCHANNEL3',3,'OUTPUTCHANNEL1',5,'OUTPUTCHANNEL2',6,'OUTPUTCHANNEL4',7,'OUTPUTGROUND',127);
enuminfo.DIGITAL_OPT=struct('SET_LOW_BITS',1,'SET_HIGH_BITS',2,'READ_LOW_BITS',3,'READ_HIGH_BITS',4);
enuminfo.MP_RETURN_CODE=struct('MPSUCCESS',1,'MPDRVERR',2,'MPDLLBUSY',3,'MPINVPARA',4,'MPNOTCON',5,'MPREADY',6,'MPWPRETRIG',7,'MPWTRIG',8,'MPBUSY',9,'MPNOACTCH',10,'MPCOMERR',11,'MPINVTYPE',12,'MPNOTINNET',13,'MPSMPLDLERR',14,'MPMEMALLOCERR',15,'MPSOCKERR',16,'MPUNDRFLOW',17,'MPPRESETERR',18,'MPPARSERERR',19);
enuminfo.MP_COM_TYPE=struct('MPUSB',10,'MPUDP',11);
enuminfo.MP_TYPE=struct('MP150',101,'MP35',102,'MP36',103);
methodinfo=fcns;